% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_ifrp.R
\name{OptimalAdaptiveIFRP}
\alias{OptimalAdaptiveIFRP}
\title{Compute optimal adaptive intrinsic factor risk premia}
\usage{
OptimalAdaptiveIFRP(
  returns,
  factors,
  penalty_parameters,
  weighting_type = "c",
  tuning_type = "g",
  include_standard_errors = FALSE,
  one_stddev_rule = FALSE,
  gcv_vr_weighting = FALSE,
  gcv_aic_scaling = TRUE,
  n_folds = 5,
  n_train_observations = 120,
  n_test_observations = 12,
  roll_shift = 12,
  relaxed = FALSE,
  plot_score = TRUE,
  check_arguments = TRUE
)
}
\arguments{
\item{returns}{(n_observations x n_returns)-dimensional matrix of test asset
excess returns.}

\item{factors}{(n_observations x n_factors)-dimensional matrix of factors.}

\item{penalty_parameters}{(n_parameters)-dimensional vector of penalty
parameter values from smallest to largest.}

\item{weighting_type}{character specifying the type of adaptive weights:
based on the correlation between factors and returns 'c'; based on the
regression coefficients of returns on factors 'b'; based on the first-step
intrinsic risk premia estimator 'a'; otherwise a vector of ones (any other
character). Default is 'c'.}

\item{tuning_type}{character indicating the parameter tuning type: 'g' for
generalized cross validation; 'c' for cross validation; 'r' for rolling
validation. Default is 'g'.}

\item{include_standard_errors}{boolean TRUE if you want to compute the
adaptive intrinsic factor risk premia HAC standard errors; FALSE otherwise.
Default is FALSE.}

\item{one_stddev_rule}{boolean TRUE for picking the most parsimonious model
whose score is not higher than one standard error above the score of the
best model; FALSE for picking the best model. Default is FALSE.}

\item{gcv_vr_weighting}{boolean TRUE for scaling pricing errors by
the inverse variance matrix of asset excess returns; False otherwise.
Default is FALSE.}

\item{gcv_aic_scaling}{(only relevant for tuning_type ='g')
boolean TRUE for AIC scaling (1 / n_observations); FALSE for BIC scaling
(log(n_observations) / n_observations). Default is TRUE.}

\item{n_folds}{(only relevant for tuning_type ='c') integer number of k-fold
for cross validation. Default is 5.}

\item{n_train_observations}{(only relevant for tuning_type ='r') number of
observations in the rolling training set. Default is 120.}

\item{n_test_observations}{(only relevant for tuning_type ='r') number of
observations in the test set. Default is 12.}

\item{roll_shift}{(only relevant for tuning_type ='r') number of observation
shift when moving from the rolling window to the next one. Default is 12.}

\item{relaxed}{boolean TRUE for re-fitting the model without shrinkage
post selection; FALSE otherwise. Default is FALSE.}

\item{plot_score}{boolean TRUE for plotting the model score; FALSE otherwise.
Default is TRUE.}

\item{check_arguments}{boolean TRUE if you want to check function arguments;
FALSE otherwise. Default is TRUE.}
}
\value{
a list containing the n_factors-dimensional vector of adaptive
intrinsic factor risk premia in "risk_premia"; the optimal penalty
parameter value in "penalty_parameter"; the model score for each penalty
parameter value.
}
\description{
Computes optimal adaptive intrinsic factor risk premia based on
pre-computed intrinsic factor risk premia and adaptive penalty weights for
various penalty parameter values. Tuning is performed via
Generalized Cross Validation (GCV), Cross Validation (CV) or Rolling
Validation (RV). Adaptive weights can be based on the correlation between
factors and returns, on the regression coefficients of returns on factors
or on the first-step intrinsic risk premia estimator. Optionally computes
the corresponding heteroskedasticity and autocorrelation robust standard
errors using the Newey-West (1994) plug-in procedure to select the number
of relevant lags, i.e., n_lags = 4 * (n_observations/100)^(2/9).
}
\examples{
# import package data on 15 risk factors and 42 test asset excess returns
factors = intrinsicFRP::factors[,-1]
returns = intrinsicFRP::returns[,-1]

penalty_parameters = seq(0., 1., length.out = 100)

# compute optimal adaptive intrinsic factor risk premia and their standard errors
aifrp = OptimalAdaptiveIFRP(
returns,
factors,
penalty_parameters,
include_standard_errors = TRUE
)

}
